fs = import('fs')
json = import('json')
curl = import('curl')
subprojects = import('subprojects')

func projects_from_wrapdb() -> list[any]
    subprojects.update('wrapdb', required: true)
    subproject('wrapdb')

    ci_config = json.parse(fs.read('subprojects/wrapdb/ci_config.json'))
    releases = json.parse(fs.read('subprojects/wrapdb/releases.json'))

    broken = ci_config.broken_linux

    res = []

    total = ci_config.keys().length()
    i = 0
    foreach proj, proj_conf : ci_config
        i += 1
        if proj.startswith('_') or proj.startswith('broken_')
            continue
        elif proj in broken
            continue
        elif proj not in releases
            continue
        elif not proj_conf.get('build_on', {}).get('alpine', true)
            continue
        endif

        wrap_version = releases[proj].versions[0]
        wrap_path_base = f'subprojects/@proj@_@wrap_version@.wrap'
        wrap_path = meson.project_source_root() / wrap_path_base

        if not fs.is_file(wrap_path)
            url = f'https://wrapdb.mesonbuild.com/v2/@proj@_@wrap_version@/@proj@.wrap'
            print(f'@0@/@1@ - @2@\n'.format(i, total, url))
            data = curl.fetch(url)
            fs.write(wrap_path, data)
        endif

        res += [{'name': proj, 'wrap_path': wrap_path_base} + proj_conf]
    endforeach

    return res
endfunc

M = {}
M.generate = func(dependencies list[custom_tgt]:)
    conf = json.parse(fs.read('config.json'))

    projects = []
    projects += projects_from_wrapdb()
    conf_found = {}

    foreach proj : projects
        packages = []
        packages_del = []
        packages += proj.get('alpine_packages', [])
        timeout = 120
        name = proj.name

        if name in conf.broken
            continue
        endif

        build_options = []
        # foreach opt : proj.get('build_options', [])
        #     if opt.startswith(f'@name@:')
        #         opt = opt.split(':')[1]
        #     endif
        #     build_options += f'-D@opt@'
        # endforeach

        if name in conf.projects
            project_conf = conf.projects[name]
            conf_found[name] = true

            if 'skip' in project_conf or 'checksum_mismatch' in project_conf
                continue
            endif

            packages += project_conf.get('alpine_packages', [])
            packages_del += project_conf.get('alpine_packages_del', [])
            timeout = project_conf.get('timeout', timeout)
            build_options += project_conf.get('options', [])
        endif

        tmp = []
        foreach package : packages
            if package not in packages_del
                tmp += package
            endif
        endforeach
        packages = tmp

        test(
            name,
            find_program('docker'),
            args: [
                'run',
                '--rm',
                '-i',
                '-v', '@0@:/home/src:ro'.format(meson.project_source_root()),
                get_option('image_tag'),
                '/home/src/docker_entry.sh',
                proj.wrap_path,
                name,
                ' '.join(packages),
                ' '.join(packages_del),
                ' '.join(build_options),
                proj.get('skip_tests', false) ? '' : '1',
            ],
            timeout: timeout,
            depends: dependencies,
        )
    endforeach

    foreach name, _ : conf.projects
        if name not in conf_found
            warning(f'unknown project: @name@')
        endif
    endforeach
endfunc

return M
